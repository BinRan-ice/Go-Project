package main

import (
	"fmt"
	"os"
)

// 错误是开发中必须要思考的问题
// - 某些系统错误 ，文件被占用，网络有延迟
// - 人为错误：核心就是一些不正常的用户会怎么来给你传递参数，sql注入
func main() {

	//打开一个文件 os 系统包，所有可以用鼠标和键盘能执行的事件，都可以用程序实现
	// func Open(name string) (*File, error)
	file, err := os.Open("lesson09/file/aa.txt")
	// 在开发中，我们需要思考这个错误的类型  PathError
	// 1、文件不存在 err
	// 2、文件被占用 err
	// 3、文件被损耗 err
	// 调用方法后，出现错误，需要解决
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(file.Name())
}

// 在实际工程项目中，
// 我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。
// Go语言没有提供像Java. c#语言中的try...catch异常处理方式，
// 而是通过函数返回值逐层往上抛, 如果没有人处理这个错误，程序就终止 panic

// 这种设计,鼓励工程师在代码中显式的检查错误，而非忽略错误。
// 好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码繁琐。

// Go中的错误也是一种类型。错误用内置的error类型表示。就像其他类型的，如int, float64。
// 错误值可以存储在变量中，从函数中返回，传递参数 等等。
